---
AEIP: 11
Title: Verifiable Credentials
Author: Samuel Manzanera <samuelmanzanera@protonmail.com>
Status: Draft
Type: Standard Track
Category: AERC
Created: 2023-04-04
---

## Abstract

This document aims to describe a way to leverage the standard [https://www.w3.org/TR/vc-data-model/](W3C Verifiable Credentials) on Archethic Blockchain.
They are credentials (attestations) of subjects (person, organizations, etc.) to be secury cryptographically, respecting the privacy and being verifiable.

This come along with new standard and ideas such as [https://github.com/archethic-foundation/aeip/blob/main/AEIP-10.md](Soul Bounded Tokens (SBTs)) in the Web3 to build decentralized identity
but yet issued by recognized entities while being verifiable and usable in our daily life.

Verifiable Credentials are information related to a subject and certified/attested by an issuer.

Those entities are usually represented as [https://www.w3.org/TR/did-core/](Decentralized Identifiers) to be cryptographically trusted and verified.

The verifiable credential then hold the entire attestation which can be disclosed or not according to the subject's volontee.

In order to make a verifiable but yet privacy-focused, Verifiable Presentation can be built to disclose a certain information or an information predicate to a verifier (selective credentials or zero knowlegedge proof)

To do so, the verifiable credential needs to be stored on a credential repository such as digital wallet, or in the case Web3 technology can be encoded into tokens like SBTs.

## Specification


Any verifiable credential can be a property of any token (NFT, SBT) to assert something about the receiver.

To be able to create a new SBT, the `token` transaction should be changed to support a new type of token: "soul-bounded"
```json
{
   "type": "soul-bounded",
   "AEIP": [2, 10]
}
```

Because SBT are tokens which are non-transferable, we can then define conditions as UTXO to prevent its spending if we are not the issuer.
The token will leverage the UTXO's hooks/condition to prevent any further usage of the asset.
```jsonc
//Example of unspent output generated by the token transaction
{
   from: "0faa.....abC", // address of the token (in this case the genesis address)
   amount: 100_000_000, // 1 in 10e8
   condition: "genesis_address(transaction.address) == '0faa.....abC'" // This will prevent any transfer except from the issuer
}
```

However, the SBT should get the possibility to be burnt if the receiver doesn't want to hold the asset anymore.

## Revocability

While revocability is optional, few strategies can be implemented according to the usage and the complexity involved.
Indeed, using a UTXO model, an issuer/smart contract cannot get back directly the token because it's not centralized in one place but transferred to the receiver.

1. Expiration date

A simple solution for the issuer would be to create an SBT in which the assets and its properties could have an expiration date. 
Hence, applications can rely on this attestation to check the validity of the SBT.

```json
{
  "type": "soul-bounded",
  "AEIP": [2, 10],
  "properties": {
    "expirationDate": "2024-01-01"  
  }
}

```

After some time, the issuer might decide to renew the SBT based on the claims of the receiver(i.e. financial statements, administrative information updates, etc.).

2. Smart Contract / TransactionChain

A smart contract or a transaction chain can manage the lifecycle of an SBT, allowing or disallowing the usage of an SBT.
The SBT should reference a pointer to the smart contract's address.

Application can check the eligibility of the SBT by calling the smart contract, or the SBT can be self-revocable using UTXO's hook.
The latter can be leveraged to send back the SBT to the issuer if the eligibility is not matched for any receiver's transaction or to the burning address.

```jsonc
{
  "type": "soul-bounded",
  "AEIP": [2, 10],
  "properties": {
    "eligibilityContract": "0fa....2b0" // Address of the smart contract chain attesting the eligibility
  },
  "hooks": encodedHooks
}
```
the encoded hook could represented in that form
```elixir
if getTransaction("0fa....2b0").content != "eligible" do
  add_token_transfer(to: "000....000", amount: 100_000_000, token_address: "0faa....2b0") # The token is then burnt as not valid anymore
end
```
